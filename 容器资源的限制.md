本篇引用（并不是完全引用）[使用 docker 对容器资源进行限制](http://dockone.io/article/2569)  

在使用 docker 运行容器时，一台主机上可能会运行几百个容器，这些容器虽然互相隔离，但是底层却使用着相同的 CPU、内存和磁盘资源。如果不对容器使用的资源进行限制，那么容器之间会互相影响，小的来说会导致容器资源使用不公平；大的来说，可能会导致主机和集群资源耗尽，服务完全不可用。  

docker 作为容器的管理者，自然提供了控制容器资源的功能。正如使用内核的 namespace 来做容器之间的隔离，docker 也是通过内核的 cgroups 来做容器的资源限制。  

## 1. CPU 资源  
主机上的进程会通过时间分片机制使用 CPU，CPU 的量化单位是频率，也就是每秒钟能执行的运算次数。为容器限制 CPU 资源并不能改变 CPU 的运行频率，而是改变每个容器能使用的 CPU 时间片。理想状态下，CPU 应该一直处于运算状态（并且进程需要的计算量不会超过 CPU 的处理能力）。  

### docker 限制 CPU Share  
docker 允许用户为每个容器设置一个数字，代表容器的 CPU share，默认情况下每个容器的 share 是 1024。要注意，这个 share 是相对的，本身并不能代表任何确定的意义。当主机上有多个容器运行时，每个容器占用的 CPU 时间比例为它的 share 在总额中的比例。举个例子，如果主机上有两个一直使用 CPU 的容器（为了简化理解，不考虑主机上其他进程），其 CPU share 都是 1024，那么两个容器 CPU 使用率都是 50%；如果把其中一个容器的 share 设置为 512，那么两者 CPU 的使用率分别为 67% 和 33%；如果删除 share 为 1024 的容器，剩下来容器的 CPU 使用率将会是 100%。  

总结下来，这种情况下，docker 会根据主机上运行的容器和进程动态调整每个容器使用 CPU 的时间比例。这样的好处是能保证 CPU 尽可能处于运行状态，充分利用 CPU 资源，而且保证所有容器的相对公平；缺点是无法指定容器使用 CPU 的确定值。  

**查看 CPU share 参数命令为：** `docker run --help`  
![cpu-share](https://github.com/momokanni/docker/blob/master/piture/cpu-shares.png)  

我的机器真是 2 核 CPU(阿里云服务器)，因此使用 stress 启动 2 个进程来产生计算压力：  
![--cpu](https://github.com/momokanni/docker/blob/master/piture/cpu-shares_1.png)  

在另外一个 terminal 使用 top 查看资源的使用情况：  
![top](https://github.com/momokanni/docker/blob/master/piture/cpu-shares_2.png)  

从上图中可以看到，CPU 两个核资源都达到了 96%,同时 两个个 stress 进程 CPU 使用率没有达到 100% 是因为系统中还有其他机器在运行。  

为了比较，再启动一个 share 为 512 的容器：  
命令： `docker run -it -c 512 stress --cpu 4`  

因为默认情况下，容器的 CPU share 为 1024，所以这两个容器的 CPU 使用率应该大致为 2：1，下面是启动第二个容器之后的监控截图：  
![-c 512](https://github.com/momokanni/docker/blob/master/piture/cpu-shares_03.png)  

两个容器分别启动了四个 stress 进程，第一个容器 stress 进程 CPU 使用率都在 33% 左右，第二个容器 stress 进程 CPU 使用率在 16% 左右，比例关系大致为 2：1，符合之前的预期。  

### 限制容器能使用的 CPU 核数  

上面讲述的 -c --cpu-shares 参数只能限制容器使用 CPU 的比例，或者说优先级，无法确定地限制容器使用 CPU 的具体核数；从 1.13 版本之后，docker 提供了 --cpus 参数可以限定容器能使用的 CPU 核数（如图一）。这个功能可以让我们更精确地设置容器 CPU 使用量，是一种更容易理解也因此更常用的手段。  

--cpus 后面跟着一个浮点数，代表容器最多使用的核数，可以精确到小数点二位，也就是说容器最小可以使用 0.01 核 CPU。  

在容器里启动三个 stress 来跑 CPU 压力，如果不加限制，这个容器会导致 CPU 的使用率为 300% 左右（也就是说会占用三个核的计算能力）  

**示例:** 我们可以限制容器只能使用 1.5 核数 CPU：  
命令: `docker run -it --cpus 1.5 containerId/containerName --cpu 3`  

![--cpus 1.5](https://github.com/momokanni/docker/blob/master/piture/cpu-shares_4.png)  

可以看到，每个 stress 进程 CPU 使用率大约在 50%，总共的使用率为 150%，符合 1.5 核的设置。  

如果设置的 --cpus 值大于主机的 CPU 核数，docker 会直接报错：  

![-cpus > 本机核数](https://github.com/momokanni/docker/blob/master/piture/cpu-shares_5.png)  

如果多个容器都设置了 --cpus ，并且它们之和超过主机的 CPU 核数，并不会导致容器失败或者退出，这些容器之间会竞争使用 CPU，具体分配的 CPU 数量取决于主机运行情况和容器的 CPU share 值。也就是说 --cpus 只能保证在 CPU 资源充足的情况下容器最多能使用的 CPU 数，docker 并不能保证在任何情况下容器都能使用这么多的 CPU（因为这根本是不可能的）。  

### 限制容器运行在某些 CPU 核  








