本篇引用（并不是完全引用）[使用 docker 对容器资源进行限制](http://dockone.io/article/2569)  

在使用 docker 运行容器时，一台主机上可能会运行几百个容器，这些容器虽然互相隔离，但是底层却使用着相同的 CPU、内存和磁盘资源。如果不对容器使用的资源进行限制，那么容器之间会互相影响，小的来说会导致容器资源使用不公平；大的来说，可能会导致主机和集群资源耗尽，服务完全不可用。  

docker 作为容器的管理者，自然提供了控制容器资源的功能。正如使用内核的 namespace 来做容器之间的隔离，docker 也是通过内核的 cgroups 来做容器的资源限制。  

## 1. CPU 资源  
主机上的进程会通过时间分片机制使用 CPU，CPU 的量化单位是频率，也就是每秒钟能执行的运算次数。为容器限制 CPU 资源并不能改变 CPU 的运行频率，而是改变每个容器能使用的 CPU 时间片。理想状态下，CPU 应该一直处于运算状态（并且进程需要的计算量不会超过 CPU 的处理能力）。  

### docker 限制 CPU Share  
docker 允许用户为每个容器设置一个数字，代表容器的 CPU share，默认情况下每个容器的 share 是 1024。要注意，这个 share 是相对的，本身并不能代表任何确定的意义。当主机上有多个容器运行时，每个容器占用的 CPU 时间比例为它的 share 在总额中的比例。举个例子，如果主机上有两个一直使用 CPU 的容器（为了简化理解，不考虑主机上其他进程），其 CPU share 都是 1024，那么两个容器 CPU 使用率都是 50%；如果把其中一个容器的 share 设置为 512，那么两者 CPU 的使用率分别为 67% 和 33%；如果删除 share 为 1024 的容器，剩下来容器的 CPU 使用率将会是 100%。  

总结下来，这种情况下，docker 会根据主机上运行的容器和进程动态调整每个容器使用 CPU 的时间比例。这样的好处是能保证 CPU 尽可能处于运行状态，充分利用 CPU 资源，而且保证所有容器的相对公平；缺点是无法指定容器使用 CPU 的确定值。  

**查看 CPU share 参数命令为：** `docker run --help`  
![cpu-share](https://github.com/momokanni/docker/blob/master/piture/cpu-shares.png)  

我的机器真是 4 核 CPU(i5-3230)，因此使用 stress 启动 4 个进程来产生计算压力：  
![--cpu](https://github.com/momokanni/docker/blob/master/piture/cpu-shares_1.png)  

在另外一个 terminal 使用 top 查看资源的使用情况：  
![top](https://github.com/momokanni/docker/blob/master/piture/cpu-shares_2.png)  

从上图中可以看到，CPU 四个核资源都达到了 96%,同时 四个 stress 进程 CPU 使用率没有达到 100% 是因为系统中还有其他机器在运行。  

为了比较，再启动一个 share 为 512 的容器：  
命令： `docker run -it -c 512 stress --cpu 4`  

因为默认情况下，容器的 CPU share 为 1024，所以这两个容器的 CPU 使用率应该大致为 2：1，下面是启动第二个容器之后的监控截图：  
![-c 512](https://github.com/momokanni/docker/blob/master/piture/cpu-shares_3.png)  




